#!csharp

// Image viewer
#r "../../imageLab/ImageLab.Flip/bin/Release/net6.0/ImageLab.Flip.dll"
#r "nuget: SimpleImageIO"

// Plotting stuff
#r "nuget: Plotly.NET, 2.0.0-preview.18"
#r "nuget: Plotly.NET.Interactive, 2.0.0-preview.18"

using Plotly.NET;
using System.IO;
using SimpleImageIO;
using ImageLab.Flip;
using ImageLab.GUI.Util;

HTML(Flip.MakeHeader())

#!markdown

Load the rendered 1spp moment images and the denoised ground truth, apply different filterings and visually compare the generated masks.

#!csharp

#r "../VcmExperiment/bin/Release/net6.0/VcmExperiment.dll"
using EfficiencyAwareMIS.VcmExperiment;
using System.Text.Json;

#!csharp

float[] numLightPathCandidates = new[] { 0.25f, 0.5f, 0.75f, 1.0f, 2.0f };
int[] numConnectionsCandidates = new[] { 0, 1, 2, 4, 8, 16 };
int width = 640; int height = 480;

var candidates = new List<Candidate>();
foreach (float lightRatio in numLightPathCandidates) {
    int numLightPaths = (int)(lightRatio * width * height);
    foreach (int numConnect in numConnectionsCandidates) {
        foreach (bool merge in new[] { true, false }) {
            candidates.Add(new(numLightPaths, numConnect, merge));
        }
    }
}
candidates.Add(new(0, 0, false)); // Path tracer

(MonochromeImage, MonochromeImage, (int, int?, bool?)) Optimize(CostHeuristic costHeuristic, 
                                                                Dictionary<Candidate, MonochromeImage> moments, 
                                                                Dictionary<Candidate, MonochromeImage> filtered,
                                                                RgbImage reference) {
    VcmOptimizer.OptimizePerPixel(filtered, costHeuristic, true, true, out var mergeMask, out var connectMask);

    MonochromeImage pixelIntensities = new(reference, MonochromeImage.RgbConvertMode.Average);
    var global = VcmOptimizer.OptimizePerImage(moments, pixelIntensities, numLightPathCandidates,
    numConnectionsCandidates, costHeuristic, mergeMask.GetPixel, connectMask.GetPixel, true, true,
    "GlobalStuff.exr");

    return (mergeMask, connectMask, global);
}

void TestFilter(string scene, float exposure, Func<MonochromeImage, MonochromeImage> filterMoments,
                Func<MonochromeImage, MonochromeImage> filterMergeMask, 
                Func<MonochromeImage, MonochromeImage> filterConnectMask) {
    string dir = "../VcmExperiment/Results/Filtering/" + scene;
    RgbImage reference = new(Path.Join(dir, "Reference.exr"));
    RgbImage render = new(Path.Join(dir, "MomentEstimator", "Render.exr"));

    // Initialize the cost heuristic statistics
    string path = Path.Join(dir, "MomentEstimator", "Render.json");
    var json = JsonDocument.Parse(File.ReadAllText(path));
    float avgCamLen = json.RootElement.GetProperty("AverageCameraPathLength").GetSingle();
    float avgLightLen = json.RootElement.GetProperty("AverageLightPathLength").GetSingle();
    float avgPhoton = json.RootElement.GetProperty("AveragePhotonsPerQuery").GetSingle();
    CostHeuristic costHeuristic = new();
    costHeuristic.UpdateStats(width * height, width * height, avgCamLen, avgLightLen, avgPhoton);

    // Gather moment estimates
    var momentLayers = Layers.LoadFromFile(Path.Join(dir, "MomentEstimator", "RenderMoments.exr"));
    Dictionary<Candidate, MonochromeImage> momentImages = new();
    foreach (var c in candidates) {
        momentImages[c] = momentLayers[c.ToString()] as MonochromeImage;
    }
    Dictionary<Candidate, MonochromeImage> filtered = new();
    foreach (var (c, img) in momentImages) {
        filtered.Add(c, filterMoments(img));
    }

    // Compute and filter merge and connect masks
    var (merge, connect, global) = Optimize(costHeuristic, momentImages, filtered, reference);
    merge = filterMergeMask(merge);
    connect = filterConnectMask(connect);

    ToneMapExposure mapExposure = new() { Exposure = exposure };
    FalseColor connectColor = new(new LinearColormap(0, 16));
    FalseColor mergeColor = new(new LinearColormap(0, 1));

    string groundTruthDir = "../VcmExperiment/Results/GroundTruth/" + scene;
    var masks = Layers.LoadFromFile(groundTruthDir + $"/Masks.exr");
    var lines = System.IO.File.ReadAllLines(groundTruthDir + $"/GlobalCounts.txt");

    HTML(Flip.Make(
        ("Connect", connectColor.Apply(connect)), 
        ("Connect (ground truth)", connectColor.Apply(masks["connect-moment"])), 
        ("Merge", mergeColor.Apply(merge)), 
        ("Merge (ground truth)", mergeColor.Apply(masks["merge-moment"])), 
        ("Reference", mapExposure.Apply(reference)),
        ("Render", mapExposure.Apply(render))
    )).Display();

    HTML("<p>Global optimization:</p>").Display();
    new Dictionary<string, int>() {
        { "Filtered", global.Item1 },
        { "Ground truth", int.Parse(lines[2]) }
    }.Display();
}

#!markdown

## Without any filtering

#!csharp

TestFilter("LampCausticNoShade", 1.0f, moment => moment, merge => merge, connect => connect);

#!markdown

## Our filtering method

#!csharp

TestFilter("LampCausticNoShade", 1, moment => {
    MonochromeImage buf = new(moment.Width, moment.Height);
    Filter.RepeatedBox(moment, buf, 3);
    return buf;
}, merge => { 
    MonochromeImage buf = new(merge.Width, merge.Height);
    Filter.Dilation(merge, buf, 16);
    Filter.RepeatedBox(buf, merge, 16);
    return merge;
}, connect => {
    MonochromeImage buf = new(connect.Width, connect.Height);
    Filter.Dilation(connect, buf, 4);
    Filter.RepeatedBox(buf, connect, 16);
    return connect;
});

#!markdown

## Evaluation of different filter settings
